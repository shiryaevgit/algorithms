```variant#1

func search(nums []int, target int) int {
	// Инициализация переменных l (левая граница) и r (правая граница).
	l, r := 0, len(nums)

	for r-l > 1 { // идем по циклу пока указатели не будут рядом

		m := (l + r) / 2 // Находим середину массива.

		if nums[m] <= target { // находим новую зону поиска, сдвигаем один из указателей
			l = m
		} else {
			r = m
		}
	}

	if nums[l] == target { // на выходе, когда указатели "соседи", сверяем левый с таргет
		return l
	}
	return -1
}

```
найти индекс target, если его нет -1


Оценка по времени: O(log n), где n - количество элементов  
log n с основанием 2

Оценка по памяти:
O(1)

Объяснение решения:
1. инициализируем два крайних указателя, равных 0 и длине массива
2. идем по циклу пока l и r не соседи
3. на каждом цикле находим новую середину
4. в зависимости того с какой из сторон находится таргет сдвигаем указатели, обозначая тем самым новую зону поиска
5. когда l и r соседи, выходим из цикла, проверяем равен ли nums[l]==target 
6. по результату возвращаем его индекс l или -1
```variant#2

```